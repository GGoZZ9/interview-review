https://cloud.tencent.com/developer/article/1698363
https://www.joshua317.com/article/189
Java代码被编译器编译成字节码之后，JVM开辟一片内存空间（也叫运行时数据区），通过类加载器加到到运行时数据区来存储程序执行期间需要用到的数据和相关信息，在这个数据区中，它由以下几部分组成：


运行时数据区中由所有程序共享的是：方法区（包括运行时常量池）Method Area，堆 Heap
线程隔离的数据区有：虚拟机栈 VM Stack（当前栈帧：局部变量表，操作数栈，动态连接，返回地址），本地方法栈 Native Method Stack，程序计数器 Program Counter Register

堆 Heap ：线程共享，所有的对象实例以及数组都在堆上分配。回收器主要管理的对象
方法区 Method Area: 线程共享，存储类信息(已被虚拟机加载的类信息)，常量，静态变量，即时编译器编译后的代码  (堆的一个逻辑部分)
                   方法区可存储的内容有：类的全路径名、类的直接超类的权全限定名、类的访问修饰符、类的类型（类或接口）、类的直接接口全限定名的有序列表、
                   常量池（字段，方法信息，静态变量，类型引用（class））等。
方法栈 JVM Stack: 线程私有，存储局部变量表，操作栈（操作数栈 Operand Stack），动态链接，方法出口，对象指针
                 每个线程会有一个私有的栈。每个线程中方法的调用又会在本栈中创建一个栈帧。
                 在方法栈中会存放编译期可知的各种基本数据类型，对象引用（reference 类型，它不等同于对象本身）
                 局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。
                 (每个方法从调用直至完成的过程，都对应着一个栈帧从入栈到出栈的过程)

 动态链接：1、栈帧中保存了一个引用，相当于C语言中的指针；

         2、该引用指向该方法在运行时常量池中的位置；

         3、运行时常量池的符号引用（指向堆），完成将符号引用转化为直接引用。

本地方法栈（Native Method Stack）：线程私有。为虚拟机使用到的Native 方法服务。如Java使用c或者c++编写的接口服务时，代码在此区运行。
程序计数器（Program Counter Register）：线程私有。有些文章也翻译成PC寄存器（PC Register），同一个东西。它可以看作是当前线程所执行的字节码的行号指示器。指向下一条要执行的指令。


如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError 异常

方法区与堆有很多共性：线程共享、内存不连续、可扩展、可垃圾回收，同样当无法再扩展时会抛出OutOfMemoryError异常。

虚拟机栈是线程私有的内存区域，生命周期与线程相同。它描述的是Java方法执行的内存模型，每个方法执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息
每个方法从调用直至完成的过程，都对应着一个栈帧从入栈到出栈的过程
每当一个方法执行完成时，该栈帧就会弹出栈帧的元素作为这个方法的返回值，并且清除这个栈帧


很多开发人员会把Java内存分为堆内存（Heap）和栈内存（Stack），这种划分的流行只能说明大多数开发人员最关注、与对象内存分配关系最密切的内存区域是这两块，
其中所指的“堆”在后面会讲到，而所指的“栈”就是JVM栈，或者说是JVM栈中的局部变量表部分。实际上Java内存区域的划分远比这要复杂。

JVM在程序运行时的内存分配有三个地方：
堆
栈
静态方法区
常量区
1. 基本数据类型的存储
A.基本数据类型的局部变量
*定义基本数据类型的局部变量以及数据都是直接存储在内存中的栈上，也就是前面说到的“虚拟机栈”，数据本身的值就是存储在栈空间里面。
*我们声明并初始化基本数据类型的局部变量时，变量名以及字面量值都是存储在栈中，而且是真实的内容。
*基本数据类型的数据本身是不会改变的，当局部变量重新赋值时，并不是在内存中改变字面量内容，而是重新在栈中寻找已存在的相同的数据，若栈中不存在，则重新开辟内存存新数据，
并且把要重新赋值的局部变量的引用指向新数据所在地址。

B. 基本数据类型的成员变量,就是在类体中定义的变量。
基本数据类型的成员变量名和值都存储于堆中，其生命周期和对象的是一致的。

C. 基本数据类型的静态变量
方法区用来存储一些共享数据，因此基本数据类型的静态变量名以及值存储于方法区的运行时常量池中，静态变量随类加载而加载，随类消失而消失

2. 引用数据类型的存储:
上面提到：堆是用来存储对象本身和数组，而引用（句柄）存放的是实际内容的地址值，因此通过上面的程序运行图，也可以看出，当我们定义一个对象时

Person per=new Person();
实际上，它也是有两个过程：

Person per;//定义变量
per=new Person();//赋值
在执行Person per;时，JVM先在虚拟机栈中的变量表中开辟一块内存存放per变量，在执行per=new Person()时，JVM会创建一个Person类的实例对象并在堆中开辟一块内存存储这个实例，同时把实例的地址值赋值给per变量。因此可见：
对于引用数据类型的对象/数组，变量名存在栈中，变量值存储的是对象的地址，并不是对象的实际内容。

值传递和引用传递
在方法被调用时，实参通过形参把它的内容副本传入方法内部，此时形参接收到的内容是实参值的一个拷贝，因此在方法内对形参的任何操作，都仅仅是对这个副本的操作，不影响原始值的内容。

值传递传递的是真实内容的一个副本，对副本的操作不影响原内容，也就是形参怎么变化，不会影响实参对应的内容。

引用传递：
”引用”也就是指向真实内容的地址值，在方法调用时，实参的地址通过方法调用被传递给相应的形参，在方法体内，形参和实参指向通愉快内存地址，对形参的操作会影响的真实内容。

在Java中所有的参数传递，不管基本类型还是引用类型，都是值传递，或者说是副本传递。
只是在传递过程中：
如果是对基本数据类型的数据进行操作，由于原始内容和副本都是存储实际值，并且是在不同的栈区，因此形参的操作，不影响原始内容。

如果是对引用类型的数据进行操作，分两种情况，
一种是形参和实参保持指向同一个对象地址，则形参的操作，会影响实参指向的对象的内容。
一种是形参被改动指向新的对象地址（如重新赋值引用），则形参的操作，不会影响实参指向的对象的内容。