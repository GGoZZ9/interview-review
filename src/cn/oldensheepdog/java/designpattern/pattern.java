package cn.oldensheepdog.java.designpattern;


/**
 * 设计模式的原则
 * 开闭原则：OOP 中最基础的原则,类、模块、方法等应该对扩展开放，对修改关闭.提高代码的可复用性和可维护性。
 * 单一职责原则：一个类、接口或方法只负责一个职责，降低代码复杂度以及变更引起的风险
 * 依赖倒置原则：程序应该依赖于抽象类或接口，而不是具体的实现类。
 * 接口隔离原则：将不同功能定义在不同接口中实现接口隔离，避免了类依赖它不需要的接口，减少了接口之间依赖的冗余性和复杂性。
 * 里氏替换原则：开闭原则的补充，规定了任何父类可以出现的地方子类都一定可以出现，可以约束继承泛滥，加强程序健壮性。
 * 迪米特原则：也叫最少知道原则，每个模块对其他模块都要尽可能少地了解和依赖，降低代码耦合度。
 * 合成/聚合原则：尽量使用组合(has-a)/聚合(contains-a)而不是继承(is-a)达到软件复用的目的，避免滥用继承带来的方法污染和方法爆炸，方法污染指父类的行为通过继承传递给子类，但子类并不具备执行此行为的能力；方法爆炸指继承树不断扩大，底层类拥有的方法过于繁杂，导致很容易选择错误。
 * */

/**
 * 有哪些设计模式
 * 创建型： 在创建对象的同时隐藏创建逻辑，不使用 new 直接实例化对象，程序在判断需要创建哪些对象时更灵活。包括工厂/抽象工厂/单例/建造者/原型模式。
 * 结构型： 通过类和接口间的继承和引用实现创建复杂结构的对象。包括适配器/桥接模式/过滤器/组合/装饰器/外观/享元/代理模式。
 * 行为型： 通过类之间不同通信方式实现不同行为。包括责任链/命名/解释器/迭代器/中介者/备忘录/观察者/状态/策略/模板/访问者模式。
 * */

/**
 * 简单工厂模式
 * 简单工厂模式又叫静态工厂方法模式，就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建
 * 优点 实现了对责任的分割，只需要知道具体产品类所对应的参数即可，通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。
 * 缺点
 * 不易拓展，一旦添加新的产品类型，就不得不修改工厂的创建逻辑，产品类型较多时，工厂的创建逻辑可能过于复杂
 *
 * 抽象工厂模式
 * 抽象工厂模式是在简单工厂的基础上将未来可能需要修改的代码抽象出来，通过继承的方式让子类去做决定。抽象工厂里只声明方法，具体的实现交给子类（子工厂）去实现
 * */

/**
 * 观察者模式
 * 观察者模式是定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（Publish/Subscribe）模式
 * 优点
 * 定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色；
 * 观察者模式在观察目标和观察者之间建立一个抽象的耦合；
 * 观察者模式支持广播通信；
 * 观察者模式符合开闭原则（对拓展开放，对修改关闭）的要求。
 * 缺点
 * 如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间；
 * 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃；
 * 角色 Subject：抽象主题（抽象被观察者）；ConcreteSubject：具体主题（具体被观察者）；Observer：抽象观察者，是观察者者的抽象类；ConcreteObserver：具体观察者，实现抽象观察者定义的更新接口
 * */

/**
 * 装饰器模式
 * 装饰器模式是指动态地给一个对象增加一些额外的功能，同时又不改变其结构。
 * 优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。
 * 装饰器模式的关键：装饰器中使用了被装饰的对象。
 * 比如，创建一个对象“laowang”，给对象添加不同的装饰，穿上夹克、戴上帽子......，这个执行过程就是装饰者模式，实现代码如下。
 * */

/**
 * 模板方法模式
 * 定义一个模板结构，将具体内容延迟到子类去实现。
 * 优点：
 * 提高代码复用性：将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中；
 * 实现了反向控制：通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制并且符合开闭原则。
 * */

/**
 * 代理模式
 * 代理模式是给某一个对象提供一个代理，并由代理对象控制对原对象的引用。
 * 优点：
 * 代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度；
 * 可以灵活地隐藏被代理对象的部分功能和服务，也增加额外的功能和服务。
 * 缺点：
 * 由于使用了代理模式，因此程序的性能没有直接调用性能高；
 * 使用代理模式提高了代码的复杂度。
 * */

/**
 * 策略模式
 * 策略模式是指定义一系列算法，将每个算法都封装起来，并且使他们之间可以相互替换。
 * 优点：遵循了开闭原则，扩展性良好。
 * 缺点：随着策略的增加，对外暴露越来越多。
 * */

/**
 * 适配器模式
 * 适配器模式是将一个类的接口变成客户端所期望的另一种接口，从而使原本因接口不匹配而无法一起工作的两个类能够在一起工作。
 * 优点：
 * 可以让两个没有关联的类一起运行，起着中间转换的作用；
 * 灵活性好，不会破坏原有的系统。
 * 缺点：过多地使用适配器，容易使代码结构混乱，如明明看到调用的是 A 接口，内部调用的却是 B 接口的实现。
 * */

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.Locale;

/**
 * JDK常用设计模式
 * 工厂模式 java.text.DateFormat, 加密类
 * 适配器模式 把其他类适配为集合类
 * 代理模式 JDK本身的代理模式
 * 全局模式Runtime.getRuntime()
 * 装饰器
 * 模板方法 Arrays.sort()方法 要求对象实现Comparable接口
 *
 * IO使用了什么模式
 * 适配器模式：由于 InputStream 是字节流不能享受到字符流读取字符那么便捷的功能，借助 InputStreamReader 将其转为 Reader 子类，因而可以拥有便捷操作文本文件方法；
 * 装饰器模式：将 InputStream 字节流包装为其他流的过程就是装饰器模式，比如，包装为 FileInputStream、ByteArrayInputStream、PipedInputStream 等。
 * */

/**
 * Spring 框架使用的设计模式如下
 * 代理模式：在 AOP 中有使用
 * 单例模式：bean 默认是单例模式
 * 模板方法模式：jdbcTemplate
 * 工厂模式：BeanFactory
 * 观察者模式：Spring 事件驱动模型就是观察者模式很经典的一个应用，比如，ContextStartedEvent 就是 ApplicationContext 启动后触发的事件
 * 适配器模式：Spring MVC 中也是用到了适配器模式适配 Controller
 * */
public class pattern {

    public static void main(String[] args) {
        DateFormat dateFormat = DateFormat.getDateInstance();
        DateFormat dateFormatFull = DateFormat.getDateInstance(0);
        DateFormat dateFormatLong = DateFormat.getDateInstance(1);
        DateFormat dateFormat1 = DateFormat.getDateInstance(DateFormat.SHORT, Locale.CHINA);

        // 把其他类适配为集合类
        List<Integer> arrayList = java.util.Arrays.asList(new Integer[]{1,2,3});
        List<Integer> arrayList2 = java.util.Arrays.asList(1,2,3);

    }

}

