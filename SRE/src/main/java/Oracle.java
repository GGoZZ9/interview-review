/**
 * 数据库的三大范式是什么
 * 1） 第一范式：原子件，要求每一列的值不能再拆分了。
 * 2） 第二范式： 一张表只描述一个实体（若列中有冗余数据，则不满足）
 * 3）第三范式： 所有列与主键值直接相关。
 *
 * 事务的特性（ACID）是指什么
 * 1）原子性（Atomic）： 事务中的各项操作，要么全做要么全不做，任何一项操作的失败都会导致整个事务的失败。
 * 2) 一致性（Consistent）： 事务结束后系统状态是一样的。
 * 3）隔离性（Isolated）: 并发执行的事务彼此无法看到对方的中间状态。
 * 4） 持久性（Durable）:事务完成后，即使发生灾难性故障，通过日志和同步备份可以在故障发生后重建数据。
 *
 * oracle中的经常使用到得函数
 * length 长度、 lower 小写、upper 大写， to_date 转化日期， to_char转化字符
 * ltrim 去左边空格、 rtrim去右边空格，substr取字串，add_month增加或者减掉月份、to_number转变为数字
 *
 *
 * ORDER BY 关键字用于对结果集进行排序。ASC|DESC
 * GROUP BY 语句用于结合聚合函数，根据一个或多个列对结果集进行分组。可结合一些聚合函数来使用
 *
 *  UNION 操作符合并两个或多个 SELECT 语句的结果。
 *  ROUND() 函数用于把数值字段舍入为指定的小数位数。
 *
 * join
 * SQL JOIN 子句用于把来自两个或多个表的行结合起来，基于这些表之间的共同字段。
 *
 * SELECT Websites.id, Websites.name, access_log.count, access_log.date
 * FROM Websites
 * INNER JOIN access_log
 * ON Websites.id=access_log.site_id;
 *
 * 最常见的 JOIN 类型：SQL INNER JOIN（简单的 JOIN）。 SQL INNER JOIN 从多个表中返回满足 JOIN 条件的所有行。
 * INNER JOIN：如果表中有至少一个匹配，则返回行
 * LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行
 * RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行
 * FULL JOIN：只要其中一个表中存在匹配，则返回行
 *
 * UNION 操作符用于合并两个或多个 SELECT 语句的结果集。UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。
 * UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。
 * SELECT *
 * INTO newtable [IN externaldb]
 * FROM table1;
 * 在 SQL 中，我们有如下约束：
 * NOT NULL - 指示某列不能存储 NULL 值。
 * UNIQUE - 保证某列的每行必须有唯一的值。
 * PRIMARY KEY - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。
 * FOREIGN KEY - 保证一个表中的数据匹配另一个表中的值的参照完整性。
 * CHECK - 保证列中的值符合指定的条件。
 * DEFAULT - 规定没有给列赋值时的默认值。
 *
 * 更新一个包含索引的表需要比更新一个没有索引的表花费更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引。
 * 如果我们仅仅需要删除表内的数据，但并不删除表本身，那么我们该如何做呢？
 * 请使用 TRUNCATE TABLE 语句：
 * TRUNCATE TABLE table_name
 * DROP TABLE 语句用于删除表。
 * DROP INDEX 语句用于删除表中的索引。
 *
 * 视图是基于 SQL 语句的结果集的可视化的表。
 * ALTER TABLE 语句用于在已有的表中添加、删除或修改列。
 * CREATE VIEW view_name AS
 * SELECT column_name(s)
 * FROM table_name
 * WHERE condition
 * AVG() - 返回平均值
 * COUNT() - 返回行数
 * FIRST() - 返回第一个记录的值
 * LAST() - 返回最后一个记录的值
 * MAX() - 返回最大值
 * MIN() - 返回最小值
 * SUM() - 返回总和
 * SQL Scalar 函数
 * SQL Scalar 函数基于输入值，返回一个单一的值。
 *
 * 有用的 Scalar 函数：
 *
 * UCASE() - 将某个字段转换为大写
 * LCASE() - 将某个字段转换为小写
 * MID() - 从某个文本字段提取字符，MySql 中使用
 * SubString(字段，1，end) - 从某个文本字段提取字符
 * LEN() - 返回某个文本字段的长度
 * ROUND() - 对某个数值字段进行指定小数位数的四舍五入
 * NOW() - 返回当前的系统日期和时间
 * FORMAT() - 格式化某个字段的显示方式
 *
 * Hint 是Oracle 提供的一种SQL语法，它允许用户在SQL语句中插入相关的语法，从而影响SQL的执行方式。
 * 因为Hint的特殊作用，所以对于开发人员不应该在代码中使用它，Hint 更像是Oracle提供给DBA用来分析问题的工具 。在SQL代码中使用Hint，可能导致非常严重的后果，
 * 因为数据库的数据是变化的，在某一时刻使用这个执行计划是最优的，在另一个时刻，却可能很差
 *
 * Oracle 的优化器有两种： RBO (Rule-Based Optimization): 基于规则的优化器 CBO (Cost-Based Optimization): 基于代价的优化器 从Oracle 10g开始，RBO 已经被弃用，但是我们依然可以通过Hint 方式来使用它。
 *
 *  用了索引也不能提高查询效率的情况
 *  创建Oracle 索引的目的是为了避免全表扫描数据，提高查询效率，但是如果sql语句写的不好致使索引失效，反而会影响数据查询效率。以下几种情况就会导致索引失效：
 *  如果没有使用基于函数的索引，那么 where 子句中对存在索引的列使用函数时，会使优化器忽略掉这些索引。例如：
 *
 * select * from staff where trunc(birthdate) = '01-MAY-82';
 *
 * 但是把函数应用在条件上，索引是可以生效的，把上面的语句改成下面的语句，就可以通过索引进行查找。
 *
 * select * from staff where birthdate < (to_date('01-MAY-82') + 0.9999);
 *
 *      注意：对于 MIN, MAX 函数，Oracle 仍然使用索引。
 *
 * * /






/*+ALL+_ROWS*/
/**
 * 表明对语句块选择基于开销的优化方法,并获得最佳吞吐量,使资源消耗最小化.
 *  SELECT /+ALL+_ROWS/ EMP_NO,EMP_NAM,DAT_IN FROM BSEMPMS WHERE EMP_NO='SCOTT';
 * */
/*+FIRST_ROWS*/
/**
 *表明对语句块选择基于开销的优化方法,并获得最佳响应时间,使资源消耗最小化.
 * */
/*+CHOOSE*/
/*表明如果数据字典中有访问表的统计信息,将基于开销的优化方法,并获得最佳的吞吐量;
表明如果数据字典中没有访问表的统计信息,将基于规则开销的优化方法;*/

/**
 * 索引的好处
 * 第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
 * 第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
 * 第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。
 * 第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。
 * 第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。
 *
 * 坏处
 * 第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。
 * 第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。
 * 第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。
 *
 * 应该在这些列上创建索引：
 * 1、在经常需要搜索的列上建立索引可以加快检索速度；
 * 2、在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；
 * 3、在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；
 * 4、在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；
 * 5、在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；
 * 6、在经常使用在WHERE子句中的列上创建索引，加快条件的判断速度。
 *
 * 不应该创建索引的的这些列具有下列特点：
 * 第一，对于那些在查询中很少使用或参考的列不应创建索引。这是因为既然这些列很少使用到，因此有索引或者无索引并不能提高查询速度。相反，由于增加了索引反而降低了系统的维护速度和增大了空间需求。
 * 第二，对于那些只有很少数据值的列也不应增加索引。这是因为由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引并不能明显加快检索速度。
 * 第三，对于那些定义为text, image和bit数据类型的列不应增加索引。这是因为这些列的数据量要么相当大，要么取值很少。
 * 第四，当修改性能远远大于检索性能时，不应创建索引。这是因为修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能但是会降低修改性能。当减少索引时，会提高修改性能但会降低检索性能。因此，当修改性能远远大于检索性能时，不应创建索引。
 * */


public class Oracle {
}
